import hashlib
import json

DYNAMICS_MODEL_AGG_FUNC = 'mean'
PREPROCESSING_METHOD_CONFOUNDED = "confounded"
PREPROCESSING_METHOD_AMENDED = "amended"

COLUMN_NAME_STUBS_TO_DROP_FROM_RAW_DATA = (
    'iti|hz|frameRate|Unnamed|exp|trials.|order|patch_count|'
    'trial_len|resp_window|feedback_(?!manipulation_type)')
COLUMN_NAME_STUBS_TO_DROP_FROM_CLEAN_DATA = 'rt_|rc_|rl_|rle_'

TASK_TRIAL_MIN_RT = 100
TASK_TRIAL_MAX_RT = 750
TASK_MIN_ACCURACY = 0.8
PROBE_MIN_ACCURACY = 0.5
VALID_TRIALS_MIN_PROPORTION = 0.8

PROBED_TRIAL_MIN_RT = 100
PROBED_TRIAL_MAX_RT = 900

SCREENING_PARAMS = {
    'TASK_TRIAL_MIN_RT': TASK_TRIAL_MIN_RT,
    'TASK_TRIAL_MAX_RT': TASK_TRIAL_MAX_RT,
    'TASK_MIN_ACCURACY': TASK_MIN_ACCURACY,
    'PROBE_MIN_ACCURACY': PROBE_MIN_ACCURACY,
    'VALID_TRIALS_MIN_PROPORTION': VALID_TRIALS_MIN_PROPORTION, }

SCREENING_PARAMS_JSON = json.dumps(SCREENING_PARAMS,
                                   sort_keys=True).encode('utf-8')
HASHED_SCREENING_PARAMS = hashlib.md5(SCREENING_PARAMS_JSON).hexdigest()

COLUMN_NAME_IS_POOR_PERFORMANCE_PARTICIPANT = 'poor_performance_participant'
COLUMN_NAME_VALID_TRIALS_PROPORTION = 'valid_trial_pr'
COLUMN_NAME_ACCURACY_TASK_TRIALS = 'accuracy_task'
COLUMN_NAME_ACCURACY_PROBE_TRIALS = 'accuracy_probe'

COLUMN_NAME_FEEDBACK_CYCLE = 'effect_patch'

COLUMN_NAME_RAW_RESP_TIME = 'rt_output_location'
COLUMN_NAME_RAW_RESP_DURATION = 'rl_output_location'
COLUMN_NAME_RAW_RESP_COUNT = 'rc_output_location'

RAW_DATA_RESP_PARAM_COLUMN_NAMES = (
    COLUMN_NAME_RAW_RESP_TIME, COLUMN_NAME_RAW_RESP_DURATION,
    COLUMN_NAME_RAW_RESP_COUNT)

RAW_DATA_COLUMN_RENAME_DICT = dict(
    zip(RAW_DATA_RESP_PARAM_COLUMN_NAMES,
        map(lambda s: s[:2].upper(), (RAW_DATA_RESP_PARAM_COLUMN_NAMES))))

(COLUMN_NAME_RESP_TIME, COLUMN_NAME_RESP_DURATION, COLUMN_NAME_RESP_COUNT
 ) = list(RAW_DATA_COLUMN_RENAME_DICT.values())

COLUMN_NAME_IS_TRIAL_VALID = 'is_valid_trial'
COLUMN_NAME_IS_RESP_CORRECT = 'is_resp_correct'
COLUMN_NAME_FEEDBACK_TYPE = 'feedback'
COLUMN_NAME_RESP_ACCURACY = 'output_correct'
COLUMN_NAME_TRIAL_NUMBER = 'trial_num'
COLUMN_NAME_PROBED_TRIAL = 'probed_trial'
COLUMN_NAME_CONTEXT = 'context'
COLUMN_NAME_PRIOR = 'prior'
COLUMN_NAME_CYCLE_LENGTH = 'patch_length'
COLUMN_NAME_UID = 'unique_participant'
COLUMN_NAME_PARTICIPANT_SEX = 'sex'
COLUMN_NAME_PARTICIPANT_AGE = 'age'
COLUMN_NAME_DATE = 'date'
COLUMN_NAME_TASK_RESPONSE_WINDOW_DURATION = 'task_response_window_duration'
COLUMN_NAME_FEEDBACK_DURATION = 'effect_duration'
COLUMN_NAME_MAXIMAL_TASK_RT = 'maximal_task_rt'
TRIALS_SINCE_LAST_PROBED_TRIAL = 'trials_since_last_probe'

COLUMN_NAME_POTENTIAL_FEEDBACK_TRIAL = 'potential_effect_trial'
COLUMN_NAME_RSP_FEEDBACK = 'effect'

COLUMN_NAME_FEEDBACK_MANIPULATION_TYPE = 'feedback_manipulation_type'

CYCLE_LENGTH_LEVELS = ('5 Trials', '10 Trials')
CYCLE_LENGTHS = (5, 10)
PRIOR_LEVELS = (False, True)

DATE_FORMAT_1ST_FALLBACK = "%Y-%m-%d_%Hh%M.%S.%f"
DATE_FORMAT_2ND_FALLBACK = '%Y-%m-%d_%Hh%M.%S'

DATE_FORMATS = ['%Y_%b_%d_%H%M', '%Y-%m-%d_%Hh%M.%S',
                         '%m/%d/%Y_%Hh%M.%S.%f',
                         '%m-%d-%Y_%Hh%M.%S.%f', '%m-%d-%Y_%Hh.%S.%f', ]

DYNAMICS_MODEL_COLUMNS_OF_INTEREST = [
    COLUMN_NAME_FEEDBACK_TYPE,
    COLUMN_NAME_CYCLE_LENGTH,
    COLUMN_NAME_UID,
    COLUMN_NAME_PRIOR,
    COLUMN_NAME_CONTEXT,
    COLUMN_NAME_RESP_TIME,
    COLUMN_NAME_RESP_DURATION,
    COLUMN_NAME_TRIAL_NUMBER,
    COLUMN_NAME_PROBED_TRIAL,
    COLUMN_NAME_FEEDBACK_MANIPULATION_TYPE,
    COLUMN_NAME_DATE,
    TRIALS_SINCE_LAST_PROBED_TRIAL
]

OLD_FEEDBACK_LEVELS = ('blank', 'ten_agorot', 'shekel')
NEW_FEEDBACK_LEVELS = (
    'CONTROL FEEDBACK', 'NEGLIGIBLE OUTCOME', 'SUBSTANTIAL OUTCOME')
FEEDBACK_TYPE_SINGLE = [NEW_FEEDBACK_LEVELS[0]]

UPDATE_FEEDBACK_LEVELS_DICT = dict(
    zip(OLD_FEEDBACK_LEVELS, NEW_FEEDBACK_LEVELS))

TEST_KEYS_FREQ = 'freq'
TEST_KEYS_BAYES = 'bayes'
T_TEST_KEYS_SEQUENTIAL_BAYES = 'seq_bayes'
